#!/usr/bin/env python3
"""
Project Generator

Handles the final assembly of projects from analyzed components,
including file generation, structure creation, and AI-integrated comprehensive reporting.
"""

import os
import json
import shutil
import asyncio
from pathlib import Path
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

from ..reporting.ai_integrated_reporter import AIIntegratedReporter


@dataclass
class GeneratedProject:
    """Information about a generated project."""
    name: str
    path: str
    files: List[str]
    size: int
    report_path: Optional[str] = None


class ProjectGenerator:
    """Generates complete project structures with AI-integrated comprehensive reporting."""
    
    def __init__(self):
        self.ai_reporter = AIIntegratedReporter()
    
    async def generate_project(
        self,
        project_name: str,
        output_dir: str,
        files: Dict[str, str],
        project_description: str = "",
        language: str = "python",
        repositories: List[Dict] = None,
        generate_report: bool = True
    ) -> GeneratedProject:
        """
        Generate a complete project with files and AI-integrated comprehensive report.
        
        Args:
            project_name: Name of the project
            output_dir: Directory to create the project in
            files: Dictionary of {file_path: content}
            project_description: Description of the project for AI analysis
            language: Primary programming language
            repositories: List of source repository information
            generate_report: Whether to generate AI-integrated comprehensive report
            
        Returns:
            GeneratedProject with details about the created project
        """
        output_dir = Path(output_dir)
        project_path = output_dir / project_name
        
        # Create project directory
        project_path.mkdir(parents=True, exist_ok=True)
        
        # Generate files
        created_files = []
        total_size = 0
        
        for file_path, content in files.items():
            full_path = project_path / file_path
            full_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write file content
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            created_files.append(file_path)
            total_size += len(content.encode('utf-8'))
        
        # Generate AI-integrated comprehensive report
        report_path = None
        if generate_report and project_description:
            try:
                print("🤖 Generating AI-integrated project report...")
                ai_report = await self.ai_reporter.generate_ai_integrated_report(
                    str(project_path),
                    project_description,
                    language,
                    repositories or []
                )
                
                # Save as README.md in project directory
                report_path = self.ai_reporter.save_report(
                    ai_report, 
                    str(project_path), 
                    "README.md"
                )
                
                print(f"✅ AI-integrated report saved to: {report_path}")
                
            except Exception as e:
                print(f"⚠️ AI report generation failed: {e}")
                print("📝 Falling back to basic report generation...")
                
                # Fallback to basic report
                basic_report_content = self._generate_basic_report(
                    project_name, created_files, total_size, repositories or []
                )
                
                report_path = project_path / "README.md"
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(basic_report_content)
        
        return GeneratedProject(
            name=project_name,
            path=str(project_path),
            files=created_files,
            size=total_size,
            report_path=str(report_path) if report_path else None
        )
    
    def _generate_basic_report(
        self, 
        project_name: str, 
        files: List[str], 
        total_size: int,
        repositories: List[Dict]
    ) -> str:
        """Generate a basic report when AI analysis fails."""
        
        md = []
        md.append(f"# {project_name}")
        md.append("")
        md.append("## Project Overview")
        md.append(f"Generated by AutoBot Assembly System")
        md.append("")
        md.append("## Files Generated")
        md.append(f"- **Total Files:** {len(files)}")
        md.append(f"- **Total Size:** {total_size} bytes")
        md.append("")
        
        for file in files:
            md.append(f"- {file}")
        
        md.append("")
        
        if repositories:
            md.append("## Source Repositories")
            for repo in repositories:
                md.append(f"- **{repo.get('name', 'Unknown')}**: {repo.get('url', '')}")
        
        md.append("")
        md.append("---")
        md.append("*Generated by AutoBot Assembly System*")
        
        return "\n".join(md)
    
    def clone_and_analyze_repository(
        self,
        repo_url: str,
        target_dir: str,
        files_to_extract: List[str] = None
    ) -> Dict[str, Any]:
        """
        Clone a repository and analyze it for integration.
        
        Args:
            repo_url: URL of the repository to clone
            target_dir: Directory to clone into
            files_to_extract: Specific files to extract (None for all)
            
        Returns:
            Dictionary with repository analysis and extracted files
        """
        # This would integrate with the repository cloner
        # For now, return a placeholder structure
        
        repo_name = repo_url.split('/')[-1].replace('.git', '')
        
        return {
            'name': repo_name,
            'url': repo_url,
            'files_copied': files_to_extract or [],
            'purpose': 'Source repository',
            'license': None  # Would be detected from LICENSE file
        }
    
    def create_development_environment(
        self,
        project_path: str,
        technologies: List[str]
    ) -> None:
        """
        Create development environment files based on detected technologies.
        
        Args:
            project_path: Path to the project
            technologies: List of detected technologies
        """
        project_path = Path(project_path)
        
        # Create .gitignore
        gitignore_content = self._generate_gitignore(technologies)
        (project_path / '.gitignore').write_text(gitignore_content)
        
        # Create development scripts
        if 'Python' in technologies:
            self._create_python_dev_files(project_path)
        
        if 'Node.js' in technologies:
            self._create_nodejs_dev_files(project_path)
        
        if 'Docker' in technologies:
            self._create_docker_dev_files(project_path)
    
    def _generate_gitignore(self, technologies: List[str]) -> str:
        """Generate .gitignore content based on technologies."""
        gitignore = []
        
        # Common ignores
        gitignore.extend([
            "# OS generated files",
            ".DS_Store",
            "Thumbs.db",
            "",
            "# IDE files",
            ".vscode/",
            ".idea/",
            "*.swp",
            "*.swo",
            "",
            "# Environment variables",
            ".env",
            ".env.local",
            ".env.*.local",
            ""
        ])
        
        # Python
        if 'Python' in technologies:
            gitignore.extend([
                "# Python",
                "__pycache__/",
                "*.py[cod]",
                "*$py.class",
                "*.so",
                ".Python",
                "build/",
                "develop-eggs/",
                "dist/",
                "downloads/",
                "eggs/",
                ".eggs/",
                "lib/",
                "lib64/",
                "parts/",
                "sdist/",
                "var/",
                "wheels/",
                "*.egg-info/",
                ".installed.cfg",
                "*.egg",
                "venv/",
                "env/",
                ".venv/",
                ".env/",
                ""
            ])
        
        # Node.js
        if 'Node.js' in technologies:
            gitignore.extend([
                "# Node.js",
                "node_modules/",
                "npm-debug.log*",
                "yarn-debug.log*",
                "yarn-error.log*",
                ".npm",
                ".yarn-integrity",
                ""
            ])
        
        # Docker
        if 'Docker' in technologies:
            gitignore.extend([
                "# Docker",
                "*.log",
                ""
            ])
        
        return "\n".join(gitignore)
    
    def _create_python_dev_files(self, project_path: Path) -> None:
        """Create Python development files."""
        # Create setup.py if it doesn't exist
        if not (project_path / 'setup.py').exists():
            setup_content = f'''from setuptools import setup, find_packages

setup(
    name="{project_path.name}",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        # Add your dependencies here
    ],
    python_requires=">=3.8",
)
'''
            (project_path / 'setup.py').write_text(setup_content)
        
        # Create Makefile for common tasks
        makefile_content = '''install:
\tpip install -r requirements.txt

test:
\tpython -m pytest tests/

lint:
\tflake8 .
\tblack --check .

format:
\tblack .

clean:
\tfind . -type f -name "*.pyc" -delete
\tfind . -type d -name "__pycache__" -delete

.PHONY: install test lint format clean
'''
        (project_path / 'Makefile').write_text(makefile_content)
    
    def _create_nodejs_dev_files(self, project_path: Path) -> None:
        """Create Node.js development files."""
        # Create basic package.json if it doesn't exist
        if not (project_path / 'package.json').exists():
            package_json = {
                "name": project_path.name.lower().replace('_', '-'),
                "version": "1.0.0",
                "description": "",
                "main": "index.js",
                "scripts": {
                    "start": "node index.js",
                    "dev": "nodemon index.js",
                    "test": "jest",
                    "lint": "eslint .",
                    "format": "prettier --write ."
                },
                "keywords": [],
                "author": "",
                "license": "MIT",
                "devDependencies": {
                    "nodemon": "^2.0.0",
                    "jest": "^29.0.0",
                    "eslint": "^8.0.0",
                    "prettier": "^2.0.0"
                }
            }
            
            with open(project_path / 'package.json', 'w') as f:
                json.dump(package_json, f, indent=2)
    
    def _create_docker_dev_files(self, project_path: Path) -> None:
        """Create Docker development files."""
        # Create docker-compose.dev.yml for development
        docker_compose_dev = '''version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - DEBUG=1
    command: python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload
'''
        (project_path / 'docker-compose.dev.yml').write_text(docker_compose_dev)