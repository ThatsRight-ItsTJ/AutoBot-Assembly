#!/usr/bin/env python3
"""
Cryptocurrency Price Tracker API

Real-time cryptocurrency price tracking with multi-exchange support,
historical data storage, and comprehensive REST API endpoints.

Generated by AutoBot Assembly System.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json

from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import httpx
import redis
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
import uvicorn

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database setup
SQLALCHEMY_DATABASE_URL = "sqlite:///./crypto_prices.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Redis setup for caching
redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

# FastAPI app
app = FastAPI(
    title="Cryptocurrency Price Tracker API",
    description="Real-time crypto price tracking with multi-exchange support",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database Models
class PriceHistory(Base):
    __tablename__ = "price_history"
    
    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String, index=True)
    exchange = Column(String, index=True)
    price = Column(Float)
    volume = Column(Float)
    timestamp = Column(DateTime, default=datetime.utcnow)

Base.metadata.create_all(bind=engine)

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Exchange APIs configuration
EXCHANGES = {
    "binance": {
        "url": "https://api.binance.com/api/v3/ticker/price",
        "symbol_format": lambda s: s.upper()
    },
    "coinbase": {
        "url": "https://api.coinbase.com/v2/exchange-rates",
        "symbol_format": lambda s: s.upper()
    },
    "kraken": {
        "url": "https://api.kraken.com/0/public/Ticker",
        "symbol_format": lambda s: s.upper()
    }
}

class CryptoPriceTracker:
    """Main cryptocurrency price tracking service."""
    
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=10.0)
        
    async def fetch_price_from_exchange(self, exchange: str, symbol: str) -> Optional[Dict]:
        """Fetch price from a specific exchange."""
        try:
            exchange_config = EXCHANGES.get(exchange)
            if not exchange_config:
                return None
                
            formatted_symbol = exchange_config["symbol_format"](symbol)
            
            if exchange == "binance":
                response = await self.client.get(
                    exchange_config["url"],
                    params={"symbol": f"{formatted_symbol}USDT"}
                )
                data = response.json()
                return {
                    "exchange": exchange,
                    "symbol": symbol,
                    "price": float(data["price"]),
                    "timestamp": datetime.utcnow()
                }
                
            elif exchange == "coinbase":
                response = await self.client.get(exchange_config["url"])
                data = response.json()
                rates = data["data"]["rates"]
                if formatted_symbol in rates:
                    return {
                        "exchange": exchange,
                        "symbol": symbol,
                        "price": 1.0 / float(rates[formatted_symbol]),
                        "timestamp": datetime.utcnow()
                    }
                    
        except Exception as e:
            logger.error(f"Error fetching {symbol} from {exchange}: {e}")
            return None
    
    async def get_multi_exchange_price(self, symbol: str) -> Dict:
        """Get price from multiple exchanges."""
        tasks = []
        for exchange in EXCHANGES.keys():
            tasks.append(self.fetch_price_from_exchange(exchange, symbol))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        prices = {}
        for result in results:
            if isinstance(result, dict) and result:
                prices[result["exchange"]] = {
                    "price": result["price"],
                    "timestamp": result["timestamp"].isoformat()
                }
        
        return {
            "symbol": symbol.upper(),
            "prices": prices,
            "average_price": sum(p["price"] for p in prices.values()) / len(prices) if prices else 0,
            "timestamp": datetime.utcnow().isoformat()
        }

# Initialize tracker
tracker = CryptoPriceTracker()

@app.get("/")
async def root():
    """API root endpoint."""
    return {
        "message": "Cryptocurrency Price Tracker API",
        "version": "1.0.0",
        "endpoints": {
            "current_price": "/price/{symbol}",
            "multi_exchange": "/price/{symbol}/exchanges",
            "historical": "/price/{symbol}/history",
            "supported_exchanges": "/exchanges"
        }
    }

@app.get("/price/{symbol}")
async def get_current_price(symbol: str):
    """Get current price for a cryptocurrency."""
    # Check cache first
    cache_key = f"price:{symbol.upper()}"
    cached_price = redis_client.get(cache_key)
    
    if cached_price:
        return json.loads(cached_price)
    
    # Fetch from exchanges
    price_data = await tracker.get_multi_exchange_price(symbol)
    
    # Cache for 30 seconds
    redis_client.setex(cache_key, 30, json.dumps(price_data))
    
    return price_data

@app.get("/price/{symbol}/exchanges")
async def get_multi_exchange_prices(symbol: str):
    """Get prices from all supported exchanges."""
    return await tracker.get_multi_exchange_price(symbol)

@app.get("/price/{symbol}/history")
async def get_price_history(
    symbol: str, 
    hours: int = 24,
    db: Session = Depends(get_db)
):
    """Get historical price data."""
    start_time = datetime.utcnow() - timedelta(hours=hours)
    
    history = db.query(PriceHistory).filter(
        PriceHistory.symbol == symbol.upper(),
        PriceHistory.timestamp >= start_time
    ).order_by(PriceHistory.timestamp.desc()).all()
    
    return {
        "symbol": symbol.upper(),
        "period_hours": hours,
        "data_points": len(history),
        "history": [
            {
                "exchange": record.exchange,
                "price": record.price,
                "volume": record.volume,
                "timestamp": record.timestamp.isoformat()
            }
            for record in history
        ]
    }

@app.get("/exchanges")
async def get_supported_exchanges():
    """Get list of supported exchanges."""
    return {
        "supported_exchanges": list(EXCHANGES.keys()),
        "total_exchanges": len(EXCHANGES)
    }

@app.post("/price/{symbol}/store")
async def store_price_data(
    symbol: str,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """Store current price data in database."""
    price_data = await tracker.get_multi_exchange_price(symbol)
    
    # Store each exchange price
    for exchange, data in price_data["prices"].items():
        price_record = PriceHistory(
            symbol=symbol.upper(),
            exchange=exchange,
            price=data["price"],
            volume=0.0,  # Volume data would need separate API calls
            timestamp=datetime.fromisoformat(data["timestamp"].replace('Z', '+00:00'))
        )
        db.add(price_record)
    
    db.commit()
    
    return {
        "message": f"Price data stored for {symbol.upper()}",
        "exchanges_stored": len(price_data["prices"])
    }

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
